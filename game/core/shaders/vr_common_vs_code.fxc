// Copyright (c) Valve Corporation, All rights reserved. ======================================================================================================
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// These functions are an attempt to standardize the lighting models across HLVR scene shaders, with the goal of accelerating shader authoring and
// homogenizing lighting calculations and making code extension easier.
//
// VS_ProcessCommonData should be called at the top of all vertex shaders and sets up a common structure that is used to communicate to our pixel shader input
//
// NOTE: These functions do the bare minimum of vertex and pixel setup.
//		 For standard world shaders that automatically support features like texture mapping, alpha transparency and normal mapping
//       there is a better starting point in the vr_shared_standard_VS_code.fxc headers
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

#ifndef VR_COMMON_VS_CODE_FXC
#define VR_COMMON_VS_CODE_FXC

//-------------------------------------------------------------------------------------------------------------------------------------------------------------

#include "math_general.fxc"
#include "instancing.fxc"
#include "vs_decompress.fxc"
#include "morph.fxc"
#include "light_probe_volume.fxc"
#include "vr_lighting.fxc"

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Common Vertex Shader Combos
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------

//
// Constants 
//
BoolAttribute( CanBatchWithDynamicShaderConstants, true );

bool g_bWrinkleOverride < Default( 0.0f ); UiType( CheckBox ); UiGroup( "Wrinkle/10" ); >;
float g_flWrinkleOverride < Default( 0.0 ); Range( -1.0, 1.0 ); UiGroup( "Wrinkle/20" ); >;

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
//
// Common Vertex Processing Code
//
//-------------------------------------------------------------------------------------------------------------------------------------------------------------
#ifdef COMMON_VS_INPUT_DEFINED

void VS_DecodeObjectSpaceNormalAndTangent( const VS_INPUT i, out float3 vNormalOs, out float4 vTangentUOs_flTangentVSign )
{
	//
	// Decompress normal and tangent basis 
	//
	float4 vInputNormalOs = i.vNormalOs;
	float4 vInputTangentUOs_flTangentVSign = float4( 0.0, 0.0, 1.0, 1.0 );
	#if ( D_COMPRESSED_NORMALS_AND_TANGENTS != 1 )
	{
		vInputNormalOs.w = 1.0f;

		#if ( VS_INPUT_HAS_TANGENT_BASIS )
		{
			vInputTangentUOs_flTangentVSign.xyzw = i.vTangentUOs_flTangentVSign.xyzw;
		}
		#else
		{
			vInputTangentUOs_flTangentVSign.xyzw = float4( 0.0, 0.0, 1.0, 1.0 );
		}
		#endif
	}
	#endif

	DecompressNormalTangent( vInputNormalOs.xyzw, vInputTangentUOs_flTangentVSign.xyzw, vNormalOs.xyz, vTangentUOs_flTangentVSign.xyzw );
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
PS_INPUT VS_CommonProcessing( VS_INPUT i )
{
	PS_INPUT o;

	//
	// Generate Object->World matrix and animation scale
	//
	ExtraShaderData_t extraShaderData;
	extraShaderData = GetExtraPerInstanceShaderData( i.nInstanceTransformID );
	
	o.vVertexColor.rgba = extraShaderData.vTint;

	//
	// Animated vertex cache   
	//
	#if ( D_CS_VERTEX_ANIMATION )
	{
		uint nVertexId = extraShaderData.nVertexCacheOffset + uint( i.nVertexCacheIndex );
		CachedAnimatedVertex_t vertex = FetchCachedVertex( nVertexId );

		float3 vNormal;
		float3 vTangent;
		float flSign;
		DecodeCachedVertexTangentSpace( vertex, vNormal, vTangent, flSign );

		o.vPositionWs.xyz = vertex.vPosWs;
		o.vNormalWs.xyz = vNormal;
		
		#if ( PS_INPUT_HAS_TANGENT_BASIS )
		{
			o.vTangentUWs.xyz = vTangent;
			o.vTangentVWs.xyz = cross( vNormal, vTangent ) * flSign;
		}
		#endif
	}
	#else
	{
		float3 vNormalOs;
		float4 vTangentUOs_flTangentVSign;

		VS_DecodeObjectSpaceNormalAndTangent( i, vNormalOs, vTangentUOs_flTangentVSign );

		float3 vPositionOs = i.vPositionOs.xyz;

		float3x4 matObjectToWorld = GetTransformMatrix( i.nInstanceTransformID, i.nBoneIndex.x );
		o.vPositionWs = mul( matObjectToWorld, float4( vPositionOs.xyz, 1.0 ) );
		
		//
		// Transform to world space
		//
		o.vNormalWs.xyz = normalize( mul( matObjectToWorld, float4( vNormalOs.xyz, 0.0 ) ) );
	
		//
		// Generate & Transform tangents
		//
		#if ( PS_INPUT_HAS_TANGENT_BASIS ) 
		{
			float3 vTangentUWs = mul( matObjectToWorld, float4( vTangentUOs_flTangentVSign.xyz, 0.0 ) );

			//
			// Force tangentU perpendicular to normal and normalize
			//
			vTangentUWs.xyz = normalize( vTangentUWs.xyz - ( o.vNormalWs.xyz * dot( vTangentUWs.xyz, o.vNormalWs.xyz ) ) );

			o.vTangentUWs.xyz = vTangentUWs.xyz;
			o.vTangentVWs.xyz = cross( o.vNormalWs.xyz, vTangentUWs.xyz ) * vTangentUOs_flTangentVSign.w;
		}
		#endif
	}
	#endif

	o.vPositionPs.xyzw = Position3WsToPs(  o.vPositionWs.xyz );

	#if ( S_USE_PER_VERTEX_CURVATURE )
	{
		o.flSSSCurvature = i.flSSSCurvature;
	}
	#endif

	//
	// Create texture coords
	//
	o.vTextureCoords.xy = i.vTexCoord.xy;
	#if ( S_UV2 )
	{
		o.vTextureCoords.zw = i.vTexCoord2.xy;
	}
	#endif

	//
	// Baked lighting	   
	//
	#if ( D_BAKED_LIGHTING_FROM_LIGHTMAP )
	{
		o.vLightmapUV.xy = i.vLightmapUV.xy * g_vLightmapUvScale.xy;
	}
	#else
	{
		o.vLightmapUV.xy = float2( 0.0, 0.0 );
	}
	#endif

	return o;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
PS_INPUT VS_CommonProcessing_Post( const PS_INPUT i )
{
	PS_INPUT o = i;
	o.vPositionWs.xyz -= g_vHighPrecisionLightingOffsetWs.xyz;
	return o;
}

#endif

#endif
