// Copyright (c) Valve Corporation, All rights reserved. ======================================================================================================

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
#ifndef VR_DETAIL_TEXTURE_FXC
#define VR_DETAIL_TEXTURE_FXC

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
float2 g_vDetailTexCoordScale < Default2( 1.0, 1.0 ); UiGroup( "Detail Texture,80/30" ); >;
float g_flDetailTexCoordRotation < Default( 0.0 ); Range( 0.0, 360.0 ); UiGroup( "Detail Texture,80/35" ); >;
float2 g_vDetailTexCoordOffset < Default2( 0.0, 0.0 ); Range2( -1.0, -1.0, 1.0, 1.0 ); UiGroup( "Detail Texture,80/40" ); >;	

static const float PI = 3.14159265359f;

float2 ComputeDetailTexCoordOffset( float2 off, float2 sc, float rotDegrees )
{
    float a = rotDegrees * PI / 180.0;
    float c = cos(a);
    float s = sin(a);
    return -0.5 * sc * float2( c - s, s + c ) + off + 0.5;
}

float4 ComputeDetailTexCoordXform( float2 sc, float rotDegrees )
{
    float a = rotDegrees * PI / 180.0;
    float c = cos(a);
    float s = sin(a);
    return sc.xxyy * float4( c, -s, s, c );
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
float g_flDetailNormalStrength < Default( 1.0 ); Range( 0.0, 1.0 ); UiGroup( "Detail Texture,80/15" ); >;

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
float2 CalculateDetailTextureCoordinates( float2 vTextureCoordinates )
{
	float4 vDetailTexCoordXform = ComputeDetailTexCoordXform( g_vDetailTexCoordScale, g_flDetailTexCoordRotation );
	float2 vDetailTexCoordOffset = ComputeDetailTexCoordOffset( g_vDetailTexCoordOffset, g_vDetailTexCoordScale, g_flDetailTexCoordRotation );
	float2 vResult;
	vResult.x = dot( vDetailTexCoordXform.xy, vTextureCoordinates.xy );
	vResult.y = dot( vDetailTexCoordXform.zw, vTextureCoordinates.xy );
	vResult.xy += vDetailTexCoordOffset.xy;
	return vResult;
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
float3 ApplyDetailNormal( float3 vNormalTs, float3 vDetailNormalTs, float flDetailMask )
{
	float4 vDetailNormalStrengthOffsetScale = float4( 0.0, 0.0, 1.0 - g_flDetailNormalStrength, g_flDetailNormalStrength );
	vDetailNormalTs.xyz = vDetailNormalStrengthOffsetScale.xyz + vDetailNormalStrengthOffsetScale.www * vDetailNormalTs.xyz;
	vDetailNormalTs.xyz = lerp( float3( 0.0, 0.0, 1.0 ), vDetailNormalTs.xyz, flDetailMask );
	vNormalTs.xyz *= vDetailNormalTs.z;
	vNormalTs.xy += vNormalTs.z * vDetailNormalTs.xy;
	return normalize( vNormalTs.xyz );
}

//-------------------------------------------------------------------------------------------------------------------------------------------------------------
float3 PhotoshopOverlay( float3 vAlbedo, float3 vDetailTexel, float flDetailMask )
{
	// Maps 128 in an 8-bit channel to exactly 0.5
	vDetailTexel.rgb *= MOD2X_SCALAR * 0.5;

	// In Photoshop, the calculation occurs in gamma space.
	// Not Srgb but close enough
	float3 vGammaAlbedo = pow( vAlbedo.rgb, 1.0 / 2.2 );

	// The lighten part
	float3 vScreen = float3( 1.0, 1.0, 1.0 ) - vGammaAlbedo.rgb;
	vScreen.rgb *= float3( 1.0, 1.0, 1.0 ) - vDetailTexel.rgb;
	vScreen.rgb = float3( 1.0, 1.0, 1.0 ) - 2.0 * vScreen.rgb;

	// The darken part
	float3 vMultiply = 2.0 * vGammaAlbedo.rgb * vDetailTexel.rgb;

	// Mixing the two...
	float3 vOverlay = step( vGammaAlbedo.rgb, float3( 0.5, 0.5, 0.5 ) );
	vOverlay.rgb = lerp( vScreen.rgb, vMultiply.rgb, vOverlay.rgb );

	// Back into linear space
	return lerp( vAlbedo.rgb, pow( vOverlay.rgb, 2.2 ), flDetailMask );
}

#endif // VR_DETAIL_TEXTURE_FXC